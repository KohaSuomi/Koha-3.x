#!/usr/bin/perl
# OpusCapita interface for Koha ILS V150211 - written by Pasi Korkalo / OUTI Kirjastot

# GNU GPL3 applies, for full license text see https://www.gnu.org/licenses/gpl.html

# This script will pick up HTML ("pseudo EPL") print mail messages generated by Koha,
# combine them by receipient, create en EPL file and (optionally) send it to OpusCapita 
# using sftp. For sftp sshpass utility is needed (apt-get install sshpass).

# The script is meant to be run as a cronjob after build_holds_queue.pl,
# process_messages.pl and gather_print_notices.pl.

# You will need to specify the name of the HTML messages-file created by Koha to be
# processed.

# The OpusCapita interface is configured in koha-conf.xml like this:
#
# <printmailProviders>
#    <opuscapita>
#        <contact>epl@contact.com</contact>
#        <targetdir>/place/for/created/epls</targetdir>
#        <usesftp>1</usesftp>
#        <user>username</user>
#        <passwd>password</passwd>
#    </opuscapita>
# </printmailProviders>

use utf8;
use strict;
#use warnings; # Causes unintitialized value in concatenation line 179 when writing to file, but not to stdout?
use Digest::MD5 qw(md5_hex);
use C4::Context;
use File::Copy;
use Text::Undiacritic qw(undiacritic);
use Switch;
use Data::Dumper;

# Get OpusCapita settings from koha_conf.xml 
print localtime . ": Getting config.\n";
my $usesftp=C4::Context->config('printmailProviders')->{'opuscapita'}->{'usesftp'};
my $sftpuser=C4::Context->config('printmailProviders')->{'opuscapita'}->{'user'};
my $sftppasswd=C4::Context->config('printmailProviders')->{'opuscapita'}->{'passwd'};
my $ipostcontact=C4::Context->config('printmailProviders')->{'opuscapita'}->{'contact'};
my $targetdirectory=C4::Context->config('printmailProviders')->{'opuscapita'}->{'targetdir_kouvola'};
my $sftpaddress=C4::Context->config('printmailProviders')->{'opuscapita'}->{'address'};


# Get the directory and the name of the file to be processed from the arguments
my $sourcefile=$ARGV[0];

unless ( $sourcefile ) {
  print "You need to enter the name of the sourcefile (html) to process.\n";
  exit 1;
}

# Read in letters file
open (LETTERS, "<:encoding(UTF-8)", "$sourcefile") or die localtime . ": Can't open LETTERS $sourcefile.";
my @lines=<LETTERS>;
close LETTERS;

print localtime . ": Processing letters in $sourcefile.\n";

# Get the actual message content from letters
my @contents=grep /<pre>/, @lines;

unless (@contents) {
  print localtime . ": No data, will end here!\n";
  exit 1;
} 

# Make EPL
# Test header
#my $eplheader="EPL111124294780TT002SD 0                $ipostcontact\r\n";
# Production header
my $eplheader="EPL1111242947800T002SD 0                $ipostcontact\r\n"; #KOUVOLA

my %epl;
my $header;
my $hashhead;

sub leadingzeros {
  # Add leading zeros to message lines 
  my $string=$_[0];
  $string=~s/\r\n/\r\n 0/g;
  return $string;
}

sub crlf {
  # Remove excess <br /> tags from start/end and convert the rest to CR+LF
  my $string=$_[0];
  $string=~s/<br \/>$//;
  $string=~s/\n$//;
  $string=~s/<br \/>/\r\n/g;
  return $string;
}

sub heuristicdiacritic {
  my $char;
  my $changed;
  my $retstring;
  my @array=split(//, $_[0]);
  foreach (@array) {
    $char=$_;
    
    # OpusCapita claims to use ISO-Latin-1, but in reality it only supports a small subset of it:
    # ISO-Latin-1 accented letters : ÅåÄäÖöÉéÈèÌìÍíÓóÒòÔôÎîÇçÆæÏïÜüÐðØøÞþßÕõÑñÛûÂâÊêËëÃãÝýÀàÁáÂâÚúÙùÿ
    # How OpusCapita sees them     : ÅåÄäÖöÉéHhLlMm{s|r}tNnGgFf¤oÜü[pXx^ü_U§]qÝäBb°jKk^c\åÖéÁáBbZzY®
    
    # Leave characters that can be used in ISO/IEC 8859-1/OpusCapita untouched
    unless ( $char =~/[A-Za-z0-9ÅåÄäÖöÉéÜüÁá]/ ) { 
      # Special handling for some characters, replace them with phonetically closest match or visual similarity
      $changed=0; 
      switch ($char) {
        case 'Ʒ' { $char='Z'; $changed=1; }
        case 'ʒ' { $char='z'; $changed=1; }
        case 'ß' { $char='B'; $changed=1; }
        # OpusCapita can't do these:
        # case 'Ɖ' { $char='Ð'; $changed=1; }
        # case 'Đ' { $char='Ð'; $changed=1; } # This is not the same as above, so don't remove either one!
        case 'ʻ' { $char='\''; $changed=1; }
      }   
      # Drop accents as fallback. Must be done this way because "else" fails in the switch/case above. Weird.
      $char=undiacritic($char) unless $changed == 1;
    }   
    $retstring=$retstring . $char;
  }
  return $retstring;
}

# Combine messages

my $combined;
my $letters;
my $notice;
my $message;

my $signature;
my %signature;

foreach (@contents) {
  undef $signature;
  $letters++;
  $notice=$_;
  $notice=~s/ *<\/*pre>//g;
    
  # Construct header
  $header=$notice;
  $header=~s/----.*/ 0/; # Add enter where ---- used to be at the end of header.
  
  # Check that letter has separators before proceeding.
  my $match=$&;
  if ( $match eq "</pre>" ) {
    print localtime . ": ERROR: Letter #" . $letters . " seem to be lacking separators (----) between the header, repeatable-part and signature.\n";
    print "\n=== Source data ===\n" . $notice . "=== Source data ends ===\n";
    print "\n" . localtime . ": Will not proceed.\n";
    exit 1;
  }

  unless ( $header =~ /EPLKFI/ ) {
    print localtime . ": ERROR: Letter #" . $letters . " seem to be lacking EPL data.\n";
    print "\n=== Source data ===\n" . $notice . "=== Source data ends ===\n";
    print "\n" . localtime . ": Will go to next line\n";
    next if $notice;
  }

  $header=crlf($header);
  # Calculate hash based on header for combining messages
  $hashhead=md5_hex($header);


  # Cut out the repeatable message part, convert enters
  $message=$notice;
  $message=~s/.*?----//;
  $message=~s/----.*//;
  $message=crlf($message);
  $message=leadingzeros($message);
  
  # Extract signature for adding it to the end of notice-letters later
  unless (defined $signature{"$hashhead"}) {
    $signature{"$hashhead"}=$notice;
    $signature{"$hashhead"}=~s/.*----/\r\n 0/g;
    $signature{"$hashhead"}=crlf($signature{"$hashhead"});
  }

  # Combine and format
  unless (defined $epl{"$hashhead"}) {
    $message=~s/.*<br \/>30/30/g;
    $epl{"$hashhead"}="$header" . "$message";
    $combined++;
  }
  else {
    $message=~s/.*<br \/>30/ 0/g;
    $epl{"$hashhead"}=$epl{"$hashhead"} . "$message";
  }

}

# Prepare to write the targetfile
my $targetfile=$sourcefile;
$targetfile=~s/.html$//;
$targetfile=~s/^.*\///;
$targetfile="$targetdirectory/$targetfile.epl";

# Create target directory if it doesn't exist
mkdir "$targetdirectory" unless -d "$targetdirectory"; 

# Open targetfile and write header 
open (EPL, ">encoding(latin1)", "$targetfile") or die localtime . ": Can't open EPL $targetfile.";
print EPL $eplheader;

# Add signatures and write it all to an EPL
foreach (keys %epl) {
  $epl{$_}=$epl{$_} . $signature{$_};

  # We need to do paging here, it doesn't happen automatically
  my @lines = split /\r\n/, $epl{$_};
  my $linesonpage=0;
  my $contpage=0;

  foreach my $line (@lines) {
   
    print EPL heuristicdiacritic($line) . "\r\n";
    $linesonpage++;
    
    # Start of a new letter, zero linecounters
    if ( $line=~m/^EPLK/ ) {
      $contpage=0;
      $linesonpage=0;
    }
    
    # First page takes 42 lines and the pages that follow take 76.
    if ( $linesonpage == 42 && $contpage == 0 ) {
      print EPL "10\r\nEPL80068\r\n";
      $linesonpage=0;
      $contpage=1;
    } elsif ( $linesonpage == 76 && $contpage == 1 ) {
      print EPL "10\r\nEPL80068\r\n";
      $linesonpage=0;
    }

  }

}

# Close file handles
close EPL;

# This is a bit ugly, but we need to open the created EPL once more and replace
# possibly unconverted characters in it with ? to prevent \x{...} mess in the letters.

open EPL, "<encoding(latin1)", "$targetfile" or die localtime . ": Can't open EPL $targetfile.";
my @epllines=<EPL>;
close EPL;

my $eplline;
open EPL, ">encoding(latin1)", "$targetfile" or die localtime . ": Can't open EPL $targetfile.";
foreach (@epllines) {
  $eplline=$_;
  $eplline=~s/\\x\{....\}/?/g;
  print EPL $eplline;
}
close EPL;

# Ok, done now, show the stats.
print localtime . ": $letters letters processed, $combined letters will be sent.\n";

# Send EPL to OpusCapita with sftp. Now since Net::SFTP is complete and utter rubbish,
# we'll just spawn a shell and use "real" sftp instead. sshpass is needed for this.
if ( $usesftp == 1 ) {
print localtime . ": Uploading to OpusCapita server.\n";
system ("sshpass -p $sftppasswd sftp $sftpuser\@$sftpaddress > /dev/null 2>&1 << EOF
put $targetfile
bye
EOF");
}

# Move the processed notices out of the way
my $processeddirectory=$sourcefile;
$processeddirectory=~m/^.+\//;
$processeddirectory="$&old_notices";
$processeddirectory=~s/^.html//; # How did this get left here?
print localtime . ": Moving source letters to $processeddirectory\n";
mkdir "$processeddirectory" unless -d "$processeddirectory";
move ("$sourcefile", "$processeddirectory");
