#!/usr/bin/perl

use Modern::Perl;
#use diagnostics;
BEGIN {
    # find Koha's Perl modules
    # test carefully before changing this
    use FindBin;
    eval { require "$FindBin::Bin/../kohalib.pl" };
}

use open qw( :std :encoding(UTF-8) );
binmode( STDOUT, ":encoding(UTF-8)" );

use Getopt::Long;
use C4::SQLHelper;
use C4::Items;
use C4::Members;
use C4::Biblio;

use ConversionTable::BorrowernumberConversionTable;
use ConversionTable::ItemnumberConversionTable;

my ( $input_file, $number, $offset, $help) = (undef,0,0,undef);
my $framework = '';
my $borrowernumberConversionTable = 'borrowernumberConversionTable';
my $itemnumberConversionTable = 'itemnumberConversionTable';

$|=1;

GetOptions(
    'f|file:s'     => \$input_file,
    'b|bnConversionTable:s'                => \$borrowernumberConversionTable,
    'i|inConversionTable:s'                => \$itemnumberConversionTable,
    'h|help'     => \$help,
);

my $usage = << 'ENDUSAGE';

This script migrates History records from PallasPro.
The History-records need to be created by the Master Migration Tool's HistoryImportChain.

This script has the following parameters :
    -h --help  : this message
    -f --file  : The lillnhis.kir-file to import.

  --bnConversionTable  From which key-value -file to read the converted borrowernumber.
                       We are adding Patrons to a database with existing Patrons, so we need to convert
                       borrowernumbers so they won't overlap with existing ones.
                       borrowernumberConversionTable has the following format, where first column is the original
                       customer id and the second column is the mapped Koha borrowernumber:

                           1001003 12001003
                           1001004 12001004
                           1001006 12001005
                           1001007 12001006
                           ...

  --inConversionTable  From which file to read the conversion between itemnumber and Item's barcode.
                       File is generated by the bulkItemImport.pl and has the following content:

                           itemnumber:newItemnumber:barcode
                           10001000:1:541N00010001
                           10001001:2:541N00010013
                           10001074:3:541N00010746
                           ...

                       Defaults to 'itemnumberConversionTable'.


This script produces the following kind of errors:

THIS HISTORY HAS NOT BEEN CHECKED-IN FOR: (SKIPPING)
Eli tämä historiatieto oli Pallaksen konversion ajalta lainassa, muttei palautettuna. Nämä ovat siirtyneet kun lainoja vietiin.
Nämä historiatiedot jäävät Kohasta pois.

NO   BIBLIO   IN KOHA FOR:
Pallaksen luettelointitietueen tietokanta_id:tä (docid) ei löydy Kohasta. Varmaankin poistettu tietue.
Joillakin tietueilla, joista puuttu biblio, niin kuintekin löytyy ihan normaalisti tuo nide tuolla nidenumerolla. Tämä on tosi outoa. Uuden niteen biblionumber on sitten eri kuin historiatiedossa ollut.

NO  BORROWER  IN KOHA FOR: NO    ITEM    IN KOHA FOR: (SKIPPING)
Pallaksen asiakastietueen tietokanta_id:tä (custid) ei löydy Kohasta. Varmaankin poistettu tietue.
Nämä historiatiedot jäävät pois Kohasta.

NO    ITEM    IN KOHA FOR: (SKIPPING)
Pallaksen nidetietueen tietokanta_id:tä (copyid) ei löydy Kohasta. Varmaankin poistettu tietue.
Nämä historiatiedot jäävät pois Kohasta.

ENDUSAGE

if ($help || not($input_file)) {
    print $usage;
    exit;
}


my $fh = IO::File->new( $input_file, "<:encoding(utf-8)" );


$borrowernumberConversionTable = ConversionTable::BorrowernumberConversionTable->new($borrowernumberConversionTable, 'read');
$itemnumberConversionTable = ConversionTable::ItemnumberConversionTable->new( $itemnumberConversionTable, 'read' );


my $dbh = C4::Context->dbh;
my $old_issuesStatement =
      $dbh->prepare(
            "INSERT INTO old_issues
                (
                    borrowernumber,
                    itemnumber,
                    issuedate,
                    returndate,
                    branchcode,
                    date_due
                )
            VALUES (?,?,?,?,?,?)"
      );
my $statisticsStatement =
#COLUMN USAGE EXPLANATIONS
#            "INSERT INTO statistics
#                (
#                    `datetime`, --when the circulation event hapened
#                    `branch`,   --borrowers homebranch
#                    `proccode`, varchar(4) DEFAULT NULL, --not needed, set undef
#                    `value` double(16,4) DEFAULT NULL, --for some reason is set to 0.0000
#                    `type` varchar(16) DEFAULT NULL, --return or issue
#                    `other` mediumtext, -- set as ''
#                    `usercode` varchar(10) DEFAULT NULL, --when returning -> set to NULL, issues -> borrower.category
#                    `itemnumber` int(11) DEFAULT NULL,
#                    `itemtype` varchar(10) DEFAULT NULL, --when returning -> set to NULL, issues -> item.itype
#                    `borrowernumber` int(11) DEFAULT NULL, --when returning -> set to NULL, issues -> borrower.borrowernumber
#                    `associatedborrower` int(11) DEFAULT NULL, --NULL
#                    `ccode` varchar(10) DEFAULT NULL, --NULL
#                )
#            VALUES (?,?,?,?,?,?,?,?,?,?,?,?)"
      $dbh->prepare(
            "INSERT INTO statistics
                (
                    `datetime`,
                    `branch`,
                    `proccode`,
                    `value`,
                    `type`,
                    `other`,
                    `usercode`,
                    `itemnumber`,
                    `itemtype`,
                    `borrowernumber`,
                    `associatedborrower`,
                    `ccode`
                )
            VALUES (?,?,?,?,?,?,?,?,?,?,?,?)"
      );

sub migrate_history {
    my ( $history, $row ) = @_;

    my $itemnumber = $itemnumberConversionTable->fetch(  $history->{itemnumber}  );
    unless ($itemnumber) {
        warn "\nHistory for legacy itemnumber ".$history->{itemnumber}." and legacy Patron ".$history->{borrowernumber}." has no Item in Koha!\n";
        next();
    }

    my $borrowernumber = $borrowernumberConversionTable->fetch( $history->{borrowernumber} );
    unless ($borrowernumber) {
        warn "\nHistory for legacy itemnumber ".$history->{itemnumber}." and legacy Patron ".$history->{borrowernumber}." has no Patron in Koha!\n";
        next();
    }

    my $item = C4::Items::GetItem($itemnumber);
    if (! $item) {
        print "\nNO    ITEM    IN KOHA FOR: (SKIPPING)\n$row\n";
        return;
    }
    my $borrower = C4::Members::GetMember(borrowernumber => $borrowernumber);
    if (! $borrower) {
        print "\nNO  BORROWER  IN KOHA FOR: (SKIPPING)\n$row\n";
        return;
    }

    if ($history->{returndate} && $borrower && $item) {#Don't add not returned (still checked-out) issues to old_issues
        $old_issuesStatement->execute(
            $borrowernumber,
            $itemnumber,
            $history->{issuedate},
            $history->{returndate},
            $borrower->{branchcode},
            '2014-05-31',
        );

        #Create statistics for the issue-event
        $statisticsStatement->execute(
            $history->{issuedate},
            $borrower->{branchcode},
            undef,
            0.0000,
            'issue',
            'history from PallasPro',
            $borrower->{categorycode},
            $itemnumber,
            $item->{itype},
            $borrowernumber,
            undef,
            undef,
        );

        #Create statistics for the return-event
        $statisticsStatement->execute(
            $history->{returndate},
            $borrower->{branchcode},
            undef,
            0.0000,
            'return',
            'history from PallasPro',
            undef,
            $itemnumber,
            undef,
            undef,
            undef,
            undef,
        );
    }
    else {
        print "\nTHIS HISTORY HAS NOT BEEN CHECKED-IN FOR: (SKIPPING)\n$row\n";
        return;
    }
}


sub newFromRow {
    no strict 'vars';
    eval shift;
    my $s = $VAR1;
    use strict 'vars';
    warn $@ if $@;
    return $s;
}

my $i = 0;
while (<$fh>) {
    $i++;
    print ".";
    print "\n$i" unless $i % 100;


    my $history = newFromRow($_);    

    migrate_history($history, $_);

    last if $i == $number;
}

